# FAF.PTR16.1 -- Project 0
> **Performed by:** Tafune Cristian-Sergiu, group FAF-202
> **Verified by:** asist. univ. Alexandru Osadcenco

## P0W1

**Task 1** -- Write a script that would print the message “Hello PTR” on the screen. Execute it.

```elixir
def print_ptr() do
    IO.puts "Hello PTR"
end
```

A simple function that prints the message "Hello PTR" on the screen.
## P0W2

**Task 1** -- Write a function that determines whether an input integer is prime.

```elixir
result = Enum.any?(2..n-1, fn i -> rem(n, i) == 0 end)
```

The number is checked if it is a prime number by dividing it with all the numbers from 2 to n-1. If the remainder is 0, then the number is not prime.

**Task 2** -- Write a function to calculate the area of a cylinder, given it’s height and
radius.

```elixir
Float.ceil(2*:math.pi()*r*(r + h), 4)
```

The area of a cylinder is calculated by multiplying the circumference of the base by the height and adding the area of the base. The result is rounded to 4 decimal places.

**Task 3** -- Write a function to reverse a list.

```elixir
Enum.reverse(list)
```

The list is reversed by using the reverse function from the Enum module.

**Task 4** -- Write a function to calculate the sum of unique elements in a list.

```elixir
Enum.reverse(list)
```

The list is reversed by using the reverse function from the Enum module.

**Task 5** -- Write a function to reverse a list.

```elixir
Enum.uniq(list) |> Enum.sum()
```

The sum is calculated by using the sum function from the Enum module. The list is made unique by using the uniq function from the Enum module.

**Task 6** -- Write a function that extracts a given number of randomly selected elements
from a list.

```elixir
Enum.take_random(list, n)
```

The function takes n random elements from the list by using the take_random function from the Enum module.

**Task 7** -- Write a function that returns the first n elements of the Fibonacci sequence.

```elixir
previous = firstFibonacciElements(n-1)
Enum.map(previous, fn x -> x end) ++ [Enum.at(previous, -1) + Enum.at(previous, -2)]
```

The result is achieved through recursion. The function returns the first n elements of the Fibonacci sequence by using the map function from the Enum module. The map function is used to add the last two elements of the list.

**Task 8** -- Write a function that, given a dictionary, would translate a sentence. Words
not found in the dictionary need not be translated.

```elixir
String.replace(original_string, ~r/\b\w+\b/, fn word ->
  Map.get(dictionary, String.to_atom(word), word)
end)
```

The sentence is translated by using the replace function from the String module. The replace function is used to replace the words in the sentence with the words from the dictionary.

**Task 9** -- Write a function that receives as input three digits and arranges them in an
order that would create the smallest possible number

```elixir
list = [n1, n2, n3] |> Enum.sort()
if Enum.at(list, 0) == 0 do
  if Enum.at(list, 1) == 0 do
    [Enum.at(list, 2), Enum.at(list, 1), Enum.at(list, 0)] |> Enum.join()
  else
    [Enum.at(list, 1), Enum.at(list, 0), Enum.at(list, 2)] |> Enum.join()
  end
else
  [Enum.at(list, 0), Enum.at(list, 1), Enum.at(list, 2)] |> Enum.join()
end
```

The number is generated by placing the digits in a list and sorting them. Then it checks if the first digit is 0. If so, it checks if the second digit is 0. If so, it places the third digit first, the second digit second and the first digit third. If not, it places the second digit first, the first digit second and the third digit third. If not, it places the first digit first, the second digit second and the third digit third.

**Task 10** -- Write a function that would rotate a list n places to the left.

```elixir
{left, right} = Enum.split(list, n)
right ++ left
```

The list is rotated by splitting it in two parts, the first n elements and the rest of the elements. Then the two parts are concatenated.

**Task 11** -- Write a function that lists all tuples a, b, c such that a^2 +b^2 = c^2 and a, b ≤ 20.

```elixir
Enum.reduce(1..20, [], fn a, acc ->
  Enum.reduce(1..20, acc, fn b, acc ->
    Enum.reduce(1..28, acc, fn c, acc ->
      if :math.pow(a, 2) + :math.pow(b, 2) == :math.pow(c, 2) do
        acc ++ [[a, b, c]]
      else
        acc
      end
    end)
  end)
end)
```

The list of tuples is generated by using the reduce function from the Enum module. The reduce function is used to iterate through all the possible values of a, b and c. If the condition is met, the tuple is added to the list.

**Task 12** -- Write a function that eliminates consecutive duplicates in a list.

```elixir
Enum.reduce(list, [], fn n, acc ->
  if Enum.at(acc, -1) == n do
    acc
  else
    acc ++ [n]
  end
end)
```

The list is generated by using the reduce function from the Enum module. The reduce function is used to iterate through all the elements of the list. If the last element of the list is equal to the current element, it is not added to the list. If not, it is added to the list.

**Task 13** -- Write a function that, given an array of strings, will return the words that can
be typed using only one row of the letters on an English keyboard layout.

```elixir
Enum.reduce(list, [], fn word, acc ->
  Enum.reduce(lines, acc, fn line, acc ->
    if Enum.all?(String.graphemes(word), fn char -> Enum.member?(line, char) end) do
      acc ++ [word]
    else
      acc
    end
  end)
end)
```

The list of words is generated by using the reduce function from the Enum module. The reduce function is used to iterate through all the words in the list. Then it iterates through all the lines of the keyboard. If all the characters of the word are in the line, the word is added to the list.

**Task 14** -- Create a pair of functions to encode and decode strings using the Caesar cipher.

```elixir
alphabet = String.graphemes("abcdefghijklmnopqrstuvwxyz")
word = String.graphemes(String.downcase(word))
Enum.reduce(word, [], fn char, acc ->
  if Enum.member?(alphabet, char) do
    index = Enum.find_index(alphabet, fn y -> y == char end)
    acc ++ [Enum.at(alphabet, rem(index + n, 26))]
  else
    acc ++ [char]
  end
end) |> Enum.join()
```

The encoded word is generated by using the reduce function from the Enum module. The reduce function is used to iterate through all the characters of the word. If the character is in the alphabet, the index of the character is found. Then the index is incremented by n and the character at the new index is added to the list. If not, the character is added to the list. The list is then joined to form a string.
The decoding part is the same as the encoding part, except that the index is decremented by n.

**Task 15** -- White a function that, given a string of digits from 2 to 9, would return all
possible letter combinations that the number could represent.

```elixir
Enum.reduce(String.graphemes(string), [], fn char, acc ->
  if acc == [] do
    numpad[char]
  else
    cartesianProduct(acc, numpad[char])
  end
end)
```

First, the numpad is defined as a map.
Then the list of combinations is generated by using the reduce function from the Enum module. The reduce function is used to iterate through all the characters of the string. If the list is empty, the list of characters corresponding to the current character is added to the list. If not, the cartesian product of the list and the list of characters corresponding to the current character is added to the list.

**Task 16** -- White a function that, given an array of strings, would group the anagrams
together.

```elixir
Enum.group_by(list, fn word -> word |> String.graphemes() |> Enum.sort() |> Enum.join() end)
```

The list of anagrams is generated by using the group_by function from the Enum module. The group_by function is used to group the words by their sorted characters.

**Task 17** -- Write a function to convert arabic numbers to roman numerals.

```elixir
Enum.reduce(@romanMap, {"", n}, fn {value, roman}, {acc, n} ->
  {acc <> String.duplicate(roman, div(n, value)), rem(n, value)}
end) |> elem(0)
```

First, the roman numbers map is defined as a map.
Then the roman numeral is generated by using the reduce function from the Enum module. The reduce function is used to iterate through all the elements of the roman map. The number is divided by the value of the roman numeral and the roman numeral is added to the string the number of times the division is. Then the remainder of the division is added to the number.

## P0W3

**Task 1** -- Create an actor that prints on the screen any message it receives.

```elixir
receive do
  message ->
    IO.puts message
end
actorPrints()
```

The actor is created by using the receive function. The receive function is used to receive any message. Then the message is printed on the screen.

**Task 2** -- Create an actor that returns any message it receives, while modifying it

```elixir
receive do
  {:integer, message} ->
    IO.puts ("Received: " <> to_string(message + 1))
  {:string, message} ->
    IO.puts ("Received: " <> String.upcase(message))
  {_, _} ->
    IO.puts("Received: What do I do with this?")
end
actorModify()
```

The actor is created by using the receive function. The receive function is used to receive any message. Then the message is printed on the screen, while modifying it. If the message is an integer, it is incremented by 1. If the message is a string, it is converted to uppercase. If the message is neither an integer nor a string, a message is printed on the screen.

**Task 3** -- Create a two actors, actor one ”monitoring” the other. If the second actor
stops, actor one gets notified via a message.

```elixir
def actorKill do
  exit(:kill)
end

def actorMonitor do
  spawn_monitor(fn -> Lab1P0W3.actorKill() end)
  receive do
    {:DOWN, _, _, _, reason} ->
      IO.puts("Actor killed. Reason: " <> to_string(reason))
  end
end
```

The actor is created by using the spawn_monitor function. The spawn_monitor function is used to create a new process and monitor it. Then the receive function is used to receive any message. If the message is a DOWN message, it means that the actor has been killed. Then a message is printed on the screen.

**Task 4** -- Create an actor which receives numbers and with each request prints out the
current average.

```elixir
average = receive do
  value ->
    calc = Float.round((num + value) / 2, 3)
    IO.puts("Current average: " <> to_string(calc))
    calc
  end
actorAverager(average)
```

The actor will receive a number and calculate the average. Then it will print the average on the screen. Then it will receive another number and calculate the average again.

**Task 5** -- Create an actor which maintains a simple FIFO queue. You should write helper
functions to create an API for the user, which hides how the queue is implemented.

```elixir
def newQueue() do
  pid = spawn(fn -> Queue.queue([]) end)
  pid
end

def queue(queueList) do
  newQueueList = receive do
    :show ->
      IO.inspect(queueList)
      queueList
    {:push, value} ->
      IO.puts("Pushed: " <> to_string(value))
      [value | queueList]
    :pop ->
      IO.puts("Popped: " <> to_string(List.last(queueList)))
      List.delete_at(queueList, -1)
  end
  queue(newQueueList)
end
```

The queue is created in a different module. The queue is created by using the spawn function. The spawn function is used to create a new process. Then the receive function is used to receive any message. If the message is :show, the queue is printed on the screen. If the message is :push, the value is added to the queue. If the message is :pop, the last element of the queue is removed.

**Task 6** -- Create a module that would implement a semaphore.

```elixir
def createSemaphore(num) do
  semaphore = spawn(fn -> Semaphore.semaphore(num) end)
  semaphore
end

def semaphore(num) do
  counter = receive do
    :acquire ->
      if num > 0 do
        IO.puts("Acquired")
        num - 1
      else
        IO.puts("Waiting")
        num
      end
    :release ->
      if num < 1 do
        IO.puts("Released")
        num + 1
      else
        IO.puts("Nothing to release")
        num
      end
  end
  semaphore(counter)
end
```

The semaphore is created in a different module. The semaphore is created by using the spawn function. The spawn function is used to create a new process. Then the receive function is used to receive any message. If the message is :acquire, the semaphore is acquired and the counter is decremented. If the message is :release, the semaphore is released and the counter is incremented.

## P0W4

**Task 1** -- Create a supervised pool of identical worker actors. The number of actors is static, given at initialization. Workers should be individually addressable. Worker actors should echo any message they receive. If an actor dies (by receiving a “kill” message), it should be restarted by the supervisor.

```elixir
def start_link do
  GenServer.start_link(__MODULE__, [])
end
```

The worker is created by using the start_link function. The start_link function is used to create a new process and link it to the current process.

```elixir
def workerEcho(pid, msg) do
  GenServer.call(pid, {:echo, msg})
end

def handle_call({:echo, msg}, _from, state) do
  {:reply, msg, state}
end
```

The worker handles the calls from the client. If the message is :echo, the message is returned to the client.

```elixir
def start_link(num) do
  Supervisor.start_link(__MODULE__, num)
end
```

The supervisor is created by using the start_link function. The start_link function is used to create a new process and link it to the current process. It will be initialized using the init function.

```elixir
def init(num) do
  children = Enum.map(
    1..num,
    fn i ->
      %{
        id: i,
        start: {WorkerPool, :start_link, []}
      }
    end
  )
  Supervisor.init(children, strategy: :one_for_one)
end
```

The init function receives the number of workers. Then it creates a list of workers. Then it initializes the supervisor with the list of workers with a strategy of one for one. If one worker dies, the supervisor will restart it.

**Task 2** -- Create a supervised processing line to clean messy strings. The first worker in the line would split the string by any white spaces (similar to Python’s str.split method). The second actor will lowercase all words and swap all m’s and n’s (you nomster!). The third actor will join back the sentence with one space between words (similar to Python’s str.join method). Each worker will receive as input the previous actor’s output, the last actor printing the result on screen. If any of the workers die because it encounters an error, the whole processing line needs to be restarted.

As it was done in task 1, each worker will be created by using the start_link function. Each worker will have a handle_call function and will return the work done by each of them. 

```elixir
# Worker 1
def workerSplitMessage(pid, msg) do
  IO.puts("Splitting message: #{msg}")
  GenServer.call(pid, {:split, msg})
end

def handle_call({:split, msg}, _from, state) do
  result = String.split(msg, " ")
  {:reply, result, state}
end

# Worker 2
def workerReplaceMessage(pid, msg) do
  IO.puts("Replacing message: #{msg}")
  GenServer.call(pid, {:replace, msg})
end

def handle_call({:replace, msg}, _from, state) do
  lowercase = Enum.map(msg, fn part -> String.downcase(part) end)
  result = Enum.map(lowercase, fn part ->
    String.graphemes(part) |> Enum.map(fn char ->
      if String.equivalent?(char, "n") do
        "m"
      else if String.equivalent?(char, "m") do
        "n"
      else
        char
      end
    end
    end) |> Enum.join("")
  end)
  {:reply, result, state}
end

# Worker 3
def workerJoinMessage(pid, msg) do
  IO.puts("Joining message: #{msg}")
  GenServer.call(pid, {:join, msg})
end

def handle_call({:join, msg}, _from, state) do
  result = Enum.join(msg, " ")
  {:reply, result, state}
end
```

The supervisor will be created by using the start_link function. The supervisor will be initialized using the init function which will create a list of workers. The supervisor will be initialized with a strategy of one for all. If one worker dies, the supervisor will restart all of them.

```elixir
def init([]) do
  children = [
    %{
      id: 1,
      start: {WorkerSplit, :start_link, []}
    },
    %{
      id: 2,
      start: {WorkerReplace, :start_link, []}
    },
    %{
      id: 3,
      start: {WorkerJoin, :start_link, []}
    }
  ]

  Supervisor.init(children, strategy: :one_for_all)
end
```

The process line will go by the result gotten from the previous worker. The first worker will split the message. The second worker will replace the message. The third worker will join the message.

```elixir
pidSplit = Supervisor.which_children(pid) |> Enum.find(fn {i, _, _, _} -> i == 1 end) |> elem(1)
pidReplace = Supervisor.which_children(pid) |> Enum.find(fn {i, _, _, _} -> i == 2 end) |> elem(1)
pidJoin = Supervisor.which_children(pid) |> Enum.find(fn {i, _, _, _} -> i == 3 end) |> elem(1)
result = WorkerJoin.workerJoinMessage(pidJoin, WorkerReplace.workerReplaceMessage(pidReplace, WorkerSplit.workerSplitMessage(pidSplit, message)))
```

## P0W5

**Task 1** -- Write an application that would visit this link. Print out the HTTP response status code, response headers and response body.

```elixir
{:ok, response} = HTTPoison.get("https://quotes.toscrape.com/")
response
```

The request is done by using the HTTPoison library by calling the get function.

**Task 2** -- Continue your previous application. Extract all quotes from the HTTP response body. Collect the author of the quote, the quote text and tags. Save the data into a list of maps, each map representing a single quote.

```elixir
{:ok, parsed} = Floki.parse_document(response.body)
quote_map = Enum.map(
  Floki.find(parsed, "div.quote"),
  fn quote ->
    quote_author = Floki.find(quote, "small.author") |> List.last() |> Floki.text()
    quote_text = Floki.find(quote, "span.text") |> List.last() |> Floki.text() |> String.slice(1..-2)
    quote_tags = Floki.find(quote, "div.tags a.tag") |> Enum.map(fn tag -> Floki.text(tag) end) |> Enum.join(", ")
    %{quote_author: quote_author, quote_text: quote_text, quote_tags: quote_tags}
  end
)
quote_map
```

The response body is parsed by using the Floki library. Then the quotes are extracted by using the Floki.find function. Then the author, text and tags are extracted from the html tag with quotes class. Author, text and tags are found inside their specific tags in the html code and extracted using the Floki.text function. The tags are joined by using the Enum.join function. The author, text and tags are put in a map and the map is added to a list.

**Task 3** -- Continue your previous application. Persist the list of quotes into a file. Encode the data into JSON format. Name the file quotes.json.

```elixir
json_data = Jason.encode!(quote_map) |> Jason.Formatter.pretty_print()
File.write("quotes.json", json_data)
```

The list of quotes is encoded into JSON format by using the Jason library. The Jason.encode! function encodes the data into JSON format. The Jason.Formatter.pretty_print function formats the JSON data into a pretty print format. The data is written into a file by using the File.write function.

## Conclusion

The laboratory work started as a big challenge when there was no prior experience with functional programming. With more documentation reading and guides, the work became easier. The first task and second tasks became the easiest one the more tasks were done. The most challengin week was week 4 as the libraries were confusing to use and errors were hard to debug.

In the end there was a lot of work done and a lot of knowledge learned about functional programming.

## Bibliography

1. [Elixir](https://elixir-lang.org/) -- Elixir official website.
2. [Elixir Documentation](https://hexdocs.pm/elixir/1.14.3/writing-documentation.html) -- Elixir documentation.
3. [HTTPoison](https://hexdocs.pm/httpoison/HTTPoison.html) -- HTTPoison documentation.
4. [Jason](https://hexdocs.pm/jason/Jason.html) -- Jason documentation.